== Distributed spatial diversity

We have studied setting up networks which have links underwater as well as above-the-air. This enables us to develop useful systems such as distributed spatial diversity enabled receiver. Spatial diversity techniques that are used in terrestrial networks usually utilize multiple antennas on the same device to improve link quality and reliability. Similarly, having multiple hydrophones/transducers on the same underwater node might help with the same but comes with the cost of a significant increase in the size due to the spatial separation that might be needed between transducers. Can we exploit a similar technique to make underwater wireless networks faster and more reliable and make that long-range communication link “just work”? With the capability to exploit distributed spatial diversity, yes you can! In this chapter, we present how one can setup a distributed spatial diveristy enabled receiver in UnetStack.

=== Key idea involved in distributed spatial diversity

Multiple communication nodes deployed at spatially distinct locations can receive independent copies of the same information. This group of receiver nodes can act as a combined spatial diversity receiver when they cooperate by sharing copies of information. We term this distributed spatial diversity. This framework is implemented in UnetStack as an agent and is referred to as Unity.

[[fig_unityoverview]]
.Cooperating receivers exploiting spatial diversity.
image::unity-overview.png[]

An illustration of the general overview of such a receiver system is shown in <<fig_unityoverview>> and few terminologies might help for further discussion:

* *Transmitter*: A node which transmits information

* *Main receiver*: A node that acts as the main receiver in a group of receiver nodes. It is the main receiver’s responsibility to decode the information.

* *Assisting receiver*: A node that acts as an assisting receiver in a group of receiver nodes. It is the assisting receiver’s responsibility to forward the relevant information to the main receiver.

The assisting receiver nodes are in cahoots with the main receiver to cooperatively share the information. This sharing of information usually happens over a short-range high-speed wired or wireless link (e.g., WiFi, Ethernet). Although, nothing stops one from using a different technology for sharing information.

=== Immediate practical advantage

Consider a case where you are on a ship with a modem deployed and you’ve been receiving status updates from a deployed AUV every few minutes. The AUV moves into an area where the connectivity is poor, and you can no longer successfully receive the status reports. We’ve all experienced being in that situation where the underwater communication link breaks, haven’t we?

If you have a second modem available on the ship, you deploy it from another part of the ship. Or maybe there is a gateway buoy deployed nearby with a modem, and you can connect to its modem. Either way, the distributed spatial diversity technique (Unity) magically uses the information from both modems to recover connectivity to the AUV!

=== How to use Unity in UnetStack3 ?

Unity is available as a premium agent and requires UnetStack 3.1 or higher. Configuring and using `Unity` agent to exploit spatial diversity is easy with just two simple steps:

1. Setup the receiver nodes to cooperate.
2. Add the Unity agent on the main receiver.

Before we get into the details of how to set it up, let us start a simulated network with 3 nodes by simply running the `netq-network.groovy` simulation script. In the following description, we will setup the Node C to be the main receiver, Node B to be the assisting receiver and Node A to be the transmitter.

==== Set up for receiver nodes to cooperate

To set up the group of receivers to cooperate over a short-range network, we use Wormhole (<<Wormholes>>) agent provided in UnetStack. Transmitter node makes a transmission that is heard at all the receiver nodes. However, it is possible that none of the nodes are able to successfully recover the information received, as the communication link is noisy. In order to share the received noisy signals among the receivers, we can connect the receiver nodes using a Wormhole. A UDP connection between the two receiver nodes, over any IP based network (Ethernet, WiFi), can be established by adding just a few lines of code on the receiver nodes as shown below:

[source]
----
container.add 'udp', new org.arl.unet.link.UdpLink()              //<1>
container.add 'wormhole', new org.arl.unet.wormhole.Wormhole()    //<2>
wormhole.dsp = 'udp'                                              //<3>
----

<1> Adds a UdpLink(<<Wired or over-the-air links>>) agent that implements a link protocol over UDP/IP for use over wired/wireless IP networks. 
<2> Adds a Wormhole agent which allows the fjåge messages to be sent between containers over a Unet link. 
<3> Tells the Wormhole agent to use the UdpLink as the Unet link to share information.

Execute these three lines of code on both the assiting and main receiver (i.e., Node B and Node C).

*Additional set up on the assisting receiver*:

From the assisting receiver, we may not want to share the information from all agents, instead, we are interested in messages that are published only on the `Physical` agent’s topic. Therefore, we need an additional setting on the assiting receiver to forward only the messages received on the `Physical` agent’s topic to be sent over the Wormhole link.

[source]
----
wormhole.publish = [topic(phy), topic(phy, Physical.SNOOP)]       //<1>
----

<1> Tells the wormhole agent to only forward the messages received on `Physical` agent's topic.

Run the above one line of code on the assiting receiver (Node B).

That’s all there is to set up the receiver nodes to share the information and cooperate (in this case over a `UdpLink`). With this set up any message received on the `Physical` agent’s topic on the assisting receivers will also be available at the main receiver.

==== Add the Unity agent on the main receiver

If you happen to have access to the `Unity` agent, it will be available by default in the stack and you don't have to add this agent to the container. However, if you do not have this added in the stack by default, this is how you add it on the main receiver (Node C).

[source]
----
container.add 'unity', new org.arl.unet.diversity.Unity()         //<1>
----

<1> Adds the `Unity` agent to the stack.

Now, you can take a look at the parameters of the `Unity` agent, type unity on the node’s web shell interface: 

[source]
----
> unity
« Spatial diversity agent »

Combines copies of information received from multiple
receivers to decode packets.

[org.arl.unet.unity.UnityParam]
  assisters = []
  enable = false
  maxAssisterRange = 100.0
  phy = phy
----

The `assisters` parameter is used to store the `Physical` agent names running on the assisting receivers that are assisting the main receiver. The user might also want to change the default value of `maxAssisterRange` if the furthest assisting receiver to the main receiver is at a distance larger than 100 m.

Since the node address of assisting receiver (Node B) is 31, we should set the following on the main receiver (Node C):

[source]
----
unity.assisters = ['phy@31']   //<1>
unity.enable = true            //<2>
----

<1> `assisters` parameter is a list of `Physical` agent names. If the assisting receiver's node address is 31 and the `Physical` agent's name is `phy` then the wormhole publishes the messages from this agent on `phy@31`'s topic on main receiver. Therefore, the assisters list contains one item 'phy@31'.
<2> `Unity` agent is enabled.

Once the assisters parameter is set, as shown above, and the `Unity` agent is enabled, you are all set and ready to see the benefits of cooperating receivers in terms of reliability and effective data rate.

=== An example run

Now that we are all set up with an assisting receiver and a main receiver cooperating over a UdpLink, we would like to see an example of `Unity` in action. Although, we will not be able to demonstrate all the scenarios in which `Unity` will be beneficial, we can show how it works and what to expect out of it.

Since we are trying to demonstrate the advantage of `Unity` here, we would like to visualize what messages are being received on different receiver nodes. So first step is to subscribe to `Physical` agent's topic and also the `Physical.SNOOP` topic to see the overheard messages. Run the following command on teh assiting receiver (Node B):

[source]
----
subscribe phy; subscribe topic(phy, Physical.SNOOP)
----

On the main receiver (Node C), run the following command:

[source]
----
subscribe phy; subscribe agent('phy@31')
----

For the purpose of this demonstration, let us modify the modulation scheme parameter on the main receiver (Node C) to an arbitrary value which is different from the transmittier (Node A) to make sure it cannot decode the received frame successfully. For this set `phy[1].frameLength = 25` on Node C and make sure that this parameter is set to a different value on transmitter (Node A).

Now, let us transmit a frame from the transmitter node (Node A) by sending a simple `TxFrameReq` message to the `Physical` agent:

[source]
----
phy << new TxFrameReq(to: 0, data: [1,2,3])
----

The transmitted frame is broadcasted in the network. Since the settings on Node A and Node C are different, we are guaranteed to see a `BadFrameNtf` message (meaning the frame is not successfully decoded) on the main receiver. But notice that the assisting receiver successfully decoded the received frame and it was forwarded over to the main receiver via the wormhole. This can be observed in the shell output:

[source]
----
phy@31 >> RxFrameNtf:INFORM[type:CONTROL from:232 rxTime:5456805687 (3 bytes)]
----

on the main receiver. Notice that this information sharing happened transparently due to our initial set up where all messages getting published on assisting receiver's `Physical` agent (recognized by phy@31 at the main receiver) are being received on the main receiver.

The `Unity` agent now utilizes this message from the assisting receiver to publish the frame on main receiver’s `Physical` agent’s topic as shown below:

[source]
----
unity >> RxFrameNtf:INFORM[type:CONTROL from:232 rxTime:4223375002 location:651.0,140.0,-5.0 (3 bytes)]
----

In this, simple example the assisting receiver was able to successfully decode the frame and it helped the main receiver via sharing this information. This is also called *Selection diversity*. The other cases where `Unity` agent will prove useful is where both assisting receiver and main receiver could not decode the frame successfully. In such cases, the information in `BadFrameNtf` messages (e.g., log-likelihood ratios of each received bit) is used to combine the information from both receivers and the `Unity` agent tries to decode the frame. This is also termed as *Diversity combining*.

The ability to utilize selection diversity and diversity combining at the same time is extremely advantageous in practice. This technique delivers tangible benefits to a user in terms of data rate and reliability over an underwater wireless link.
